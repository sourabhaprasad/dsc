<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>DSC</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	padding-inline-start: 0;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.page-description {
    margin-bottom: 2em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-uiBlue { background-color: rgba(35, 131, 226, .07); }
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-translucentGray { background-color: rgba(255, 255, 255, 0.0375); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }
.select-value-color-pageGlass { background-color: undefined; }
.select-value-color-washGlass { background-color: undefined; }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="60e74f00-7ada-4deb-89b6-f0c46730b07e" class="page serif"><header><h1 class="page-title">DSC</h1><p class="page-description"></p></header><div class="page-body"><p id="6d8178a4-c491-43e2-9ae9-297b57b2fc10" class="">Content:</p><nav id="e52cfcfa-ca8f-41ad-aabe-ead953fa6b95" class="block-color-gray table_of_contents"><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#6c58a5b2-2287-4912-bff5-08ebf4e6cc0e">Infix to Postfix</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#8fe86dfd-a9fe-4efe-b0d4-b60921c8a29b">Tower of Hanoi</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#5b7ab088-31d0-4f12-851d-0b87b632ba89">ACK</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#d7cc985e-d76b-4367-876f-bc1e3526372b">Stack</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#5136f479-7dc2-4508-bcdc-66cf0ed82d35">Queue</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#825e870b-d3db-438a-80cf-f763cb3d7d97">Circular Queue</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#71e326dc-f69a-42bf-accf-e21dfa8ea0f5">SLL</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#93f61ec5-fe48-464f-a0cd-85fe541b8029">Binary Tree Traversal</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#40fdeaff-737a-4b8b-bd97-1d12bed1344c">SLL Reversal</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#124bed24-ae90-49cb-b722-5c41c69b5ed3">Postfix</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#d80a1faf-1965-40da-9516-c558f48629a5">BST</a></div></nav><h2 id="6c58a5b2-2287-4912-bff5-08ebf4e6cc0e" class="">Infix to Postfix</h2><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="8d3f7da5-2ef5-4fa6-8447-0664ede696ae" class="code"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
// Function to return precedence of operators
int prec(char c)
{
if (c == &#x27;^&#x27;)
return 3;
else if (c == &#x27;/&#x27; || c == &#x27;*&#x27;)
return 2;
else if (c == &#x27;+&#x27; || c == &#x27;-&#x27;)
return 1;
else
return -1;
}
// Function to return associativity of operators
char associativity(char c)
{
if (c == &#x27;^&#x27;)
return &#x27;R&#x27;;
return &#x27;L&#x27;; // Default to left-associative
}
// The main function to convert infix expression to postfix expression
void infixToPostfix(char s[])
{
char postfix[1000];
int postfixIndex = 0;
int len = strlen(s);
char stack[1000];
int top = -1;
for (int i = 0; i &lt; len; i++)
{
char c = s[i];
// If the scanned character is an operand, add it to the output string.
if ((c &gt;= &#x27;a&#x27; &amp;&amp; c &lt;= &#x27;z&#x27;) || (c &gt;= &#x27;A&#x27; &amp;&amp; c &lt;= &#x27;Z&#x27;) || (c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;))
{
postfix[postfixIndex++] = c;
}
// If the scanned character is an ‘(‘, push it to the stack.
else if (c == &#x27;(&#x27;)
{
stack[++top] = c;
}
// If the scanned character is an ‘)’, pop and add to the output string from the
//stack until an ‘(‘ is encountered.
else if (c == &#x27;)&#x27;)
{
while (top &gt;= 0 &amp;&amp; stack[top] != &#x27;(&#x27;)
{
postfix[postfixIndex++] = stack[top--];
}
top--; // Pop &#x27;(&#x27;
}
// If an operator is scanned
else
{
while ( top &gt;= 0 &amp;&amp; (prec(s[i]) &lt; prec(stack[top]) ||
 prec(s[i]) == prec(stack[top]) &amp;&amp;
 associativity(s[i]) == &#x27;L&#x27;))
{
postfix[postfixIndex++] = stack[top--];
}
stack[++top] = c;
}
}
// Pop all the remaining elements from the stack
while (top &gt;= 0)
{
postfix[postfixIndex++] = stack[top--];
}
postfix[postfixIndex] = &#x27;\0&#x27;;
printf(&quot;%s\n&quot;, postfix);
}
int main()
{
char exp[] = &quot;a+b*(c^d-e)^(f+g*h)-i&quot;;
// Function call
infixToPostfix(exp);
return 0;
}</code></pre><h2 id="8fe86dfd-a9fe-4efe-b0d4-b60921c8a29b" class="">Tower of Hanoi</h2><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="227a7d36-e29d-4c74-b9a4-b34110c292cc" class="code"><code class="language-C">#include &lt;stdio.h&gt;


void towerOfHanoi(int n, char from_rod, char to_rod, char aux_rod)
{
	if (n == 1)
	{
		printf(&quot;\n Move disk 1 from rod %c to rod %c&quot;, from_rod, to_rod);
		return;
	}
	towerOfHanoi(n-1, from_rod, aux_rod, to_rod);
	printf(&quot;\n Move disk %d from rod %c to rod %c&quot;, n, from_rod, to_rod);
	towerOfHanoi(n-1, aux_rod, to_rod, from_rod);
}

int main()
{
	int n = 4; 
	towerOfHanoi(n, &#x27;A&#x27;, &#x27;C&#x27;, &#x27;B&#x27;); // A, B and C are names of rods
	return 0;
}</code></pre><h2 id="5b7ab088-31d0-4f12-851d-0b87b632ba89" class="">ACK</h2><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="92248a86-ad50-476f-9ade-f0f0e7be6d93" class="code"><code class="language-C">#include &lt;stdio.h&gt;
int ack(int m, int n)
{
	if (m == 0){
		return n+1;
	}
	else if((m &gt; 0) &amp;&amp; (n == 0)){
		return ack(m-1, 1);
	}
	else if((m &gt; 0) &amp;&amp; (n &gt; 0)){
		return ack(m-1, ack(m, n-1));
	}
}

int main(){
	int A;
	A = ack(1, 2);
	printf(&quot;%d&quot;, A);
	return 0;
}</code></pre><h2 id="d7cc985e-d76b-4367-876f-bc1e3526372b" class="">Stack</h2><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="a17b9e18-bbfa-437a-8f52-c48f71b04ab0" class="code"><code class="language-C">#include &lt;stdio.h&gt;

#include &lt;stdlib.h&gt;

#define max 10

int top = -1,a[max],item,i;
int push();
int pop();
int display();

void main()
{
    int choice;
    for(;;)
    {
        printf(&quot;\n1.Push the element\n2.Pop the element\n3.display\n4.End&quot;);
        printf(&quot;\n\nEnter the choice: &quot;);
        scanf(&quot;%d&quot;, &amp;choice);

        switch (choice)
        {
        case 1:
            push();
            break;
        case 2:
            pop();
            break;
        case 3:
            display();
            break;
        case 4:
            exit(0);

        default:
            printf(&quot;\nInvalid choice!!&quot;);
        }
}
}

int push()
{
    if (top == max - 1)
    {
        printf(&quot;\nOverflow!!&quot;);
    }
    else
    {
        printf(&quot;\nEnter the element to be added onto the stack: &quot;);
        scanf(&quot;%d&quot;, &amp;item);
        top = top + 1;
        a[top] =item;
    }
}

int pop()
{
    if (top == -1)
    {
        printf(&quot;\nUnderflow!!&quot;);
    }
    else
    {
        printf(&quot;\nPopped element: %d&quot;,a[top]);
        top = top - 1;
    }
}

int display()
{

    if (top == -1)
    {
        printf(&quot;\nUnderflow!!&quot;);
    }
    else
    {
        printf(&quot;\nElements present in the stack: \n&quot;);
        for (i = top; i &gt;= 0; i--)
            printf(&quot;%d\n&quot;,a[i]);
    }
}</code></pre><h2 id="5136f479-7dc2-4508-bcdc-66cf0ed82d35" class="">Queue</h2><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="e0d9dccc-012b-4df8-a5f6-84ee628f40b9" class="code"><code class="language-C">#include&lt;stdio.h&gt;   
#include&lt;stdlib.h&gt;  
#define max 5  
void enqueue();  
void dequeue();  
void display();  
int front = -1, rear = -1;  
int queue[max];  
void main ()  
{  
    int choice;   
    for(;;)
    {     
        
        printf(&quot;\n1.insert an element\n2.Delete an element\n3.Display the queue\n4.Exit\n&quot;);  
        printf(&quot;\nEnter your choice ?&quot;);  
        scanf(&quot;%d&quot;,&amp;choice);  
        switch(choice)  
        {  
            case 1:  
            enqueue();  
            break;  
            case 2:  
            dequeue();  
            break;  
            case 3:  
            display();  
            break;  
            case 4:  
            exit(0);  
            break;  
            default:   
            printf(&quot;\nEnter valid choice??\n&quot;);  
        }  
    }  
}  
void enqueue()  
{  
    int item;  
    printf(&quot;\nEnter the element\n&quot;);  
    scanf(&quot;\n%d&quot;,&amp;item);      
    if(rear == max-1)  
    {  
        printf(&quot;\nOVERFLOW\n&quot;);  
        return;  
    }  
    if(front == -1 &amp;&amp; rear == -1)  
    {  
        front =rear = 0;  
         
    }  
    else   
    {  
        rear = rear+1;  
    }  
    queue[rear] = item;  
    printf(&quot;\nValue inserted &quot;);  
      
}  
void dequeue()  
{  
    int item;   
    if (front == -1 || front &gt; rear)  
    {  
        printf(&quot;\nUNDERFLOW\n&quot;);  
        return;  
              
    }  
    else  
    {  
        item = queue[front];  
        if(front == rear)  
        {  
            front = -1;  
            rear = -1 ;  
        }  
        else   
        {  
            front = front + 1;  
        }  
        printf(&quot;\nvalue deleted %d&quot;,queue[front]);  
    }  
      
      
}  
      
void display()  
{  
    int i;  
    if(rear == -1)  
    {  
        printf(&quot;\nEmpty queue\n&quot;);  
    }  
    else  
    {   printf(&quot;\n values&quot;);  
        for(i=front;i&lt;=rear;i++)  
        {  
            printf(&quot;\n%d\n&quot;,queue[i]);  
        }     
    }  
}</code></pre><h2 id="825e870b-d3db-438a-80cf-f763cb3d7d97" class="">Circular Queue</h2><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="36bcb362-6806-4879-8e53-12b5f25cfc98" class="code"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define N 3
int queue[N];
int front = -1;
int rear = -1;

void enqueue(){
    int x;
    if((rear+1)%N==front){
        printf(&quot;Overflow&quot;);
    }
    else{
        printf(&quot;Enter an element: &quot;);
        scanf(&quot;%d&quot;, &amp;x);
        if(front==-1 &amp;&amp; rear==-1){
            front=rear=0;
            queue[rear]=x;
        }
        else{
            rear = (rear+1)%N;
            queue[rear]=x;
        }
    }
}

void dequeue(){
    if(front==-1 &amp;&amp; rear==-1){
        printf(&quot;Underflow!&quot;);
    }
    else if(front==rear){
        printf(&quot;The dequeued element is %d&quot;, queue[front]);
        front=rear=-1;
    }
    else{
        printf(&quot;The dequeued element is %d&quot;, queue[front]);
        front = (front+1)%N;            
    }
}

void display(){
    if(front==-1 &amp;&amp; rear==-1){
        printf(&quot;Underflow!&quot;);
    }
    else{
        int i;
        i=front;
        printf(&quot;Circular Queue is &quot;);
        while(i!=rear){
            printf(&quot;%d  &quot;,queue[i]);
            i = (i+1)%N;
        }
        printf(&quot;%d&quot;, queue[rear]);
    }
}


void main(){
    int choice;
    while(1){
        printf(&quot;\nQueue Operations are:&quot;);
        printf(&quot;\n1.Enqueue\n2.Dequeue\n3.Display\n4.Exit&quot;);
        printf(&quot;\nEnter your choice: &quot;);
        scanf(&quot;%d&quot;, &amp;choice);
        switch(choice){
            case 1:
            enqueue();
            break;
            case 2:
            dequeue();
            break;
            case 3:
            display();
            break;
            case 4:
            exit(0);
            default:
            printf(&quot;\nInvalid Choice!\n&quot;);
        }
    }
}</code></pre><h2 id="71e326dc-f69a-42bf-accf-e21dfa8ea0f5" class="">SLL</h2><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="65aedbd9-3ea6-4d85-9ae8-0902b0080259" class="code"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct node {
    int data;
    struct node *next;
};
typedef struct node NODE;

// Display Function
NODE *display(NODE *head) {
    NODE *temp;
    if (head == NULL)
        printf(&quot;\n Linked List Data&quot;);
    if (head == NULL) {
        printf(&quot;List is Empty\n&quot;);
        exit(0);
    } else {
        temp = head;
        while (temp != NULL) {
            printf(&quot;\n %d \t &quot;, temp-&gt;data);
            temp = temp-&gt;next; // Go to Next Node
        }
    }
    return head;
}

// Insert at Beginning
NODE *insert_front(NODE *head) {
    NODE *newnode;
    newnode = (NODE *)malloc(sizeof(NODE));
    printf(&quot;Enter data:\n&quot;);
    scanf(&quot;%d&quot;, &amp;(newnode-&gt;data));
    newnode-&gt;next = NULL;

    if (head == NULL) {
        head = newnode;
    } else {
        newnode-&gt;next = head;
        head = newnode;
    }
    return head;
}

// Insert at End
NODE *insert_rear(NODE *head) {
    NODE *temp, *newnode;
    newnode = (NODE *)malloc(sizeof(NODE)); // Create First Node
    printf(&quot;Enter data:\n&quot;);
    scanf(&quot;%d&quot;, &amp;(newnode-&gt;data));
    newnode-&gt;next = NULL; // Set next to NULL
    temp = head;

    if (head == NULL) {
        head = newnode; // Set first node to be head
    }
    while (temp-&gt;next != NULL) {
        temp = temp-&gt;next;
    }
    temp-&gt;next = newnode;
    return head;
}

NODE *insert_at_position(NODE *head) {
    NODE *newnode, *cur, *prev;
    int pos, i;
    newnode = (NODE *)malloc(sizeof(NODE));
    printf(&quot;Enter data:\n&quot;);
    scanf(&quot;%d&quot;, &amp;(newnode-&gt;data));
    newnode-&gt;next = NULL;
    printf(&quot;Enter position:\n&quot;);
    scanf(&quot;%d&quot;, &amp;pos);
    cur = head;
    if (pos == 1) {
        newnode-&gt;next = head;
        head = newnode;
    } else {
        for (i = 1; i &lt; pos - 1; i++) {
            cur = cur-&gt;next;
        }
        newnode-&gt;next = cur-&gt;next;
        cur-&gt;next = newnode;
    }
    return head;
}

// Delete from Beginning
NODE *delete_front(NODE *head) {
    NODE *temp;
    if (head == NULL)
        printf(&quot;\nList is Empty &quot;);
    else {
        temp = head;
        head = temp-&gt;next;
        free(temp);
        printf(&quot;\nFront End(first) node is deleted and deleted data is: %d&quot;, temp-&gt;data);
    }
    return head;
}

// Delete from End
NODE *delete_rear(NODE *head) {
    NODE *prev = 0, *cur = head;
    if (head == NULL)
        printf(&quot;\nList is Empty/Underflow of Stack&quot;);
    else {
        while (cur-&gt;next != NULL) {
            prev = cur;
            cur = cur-&gt;next;
        }
        free(cur);
        printf(&quot;\nRear End(Last) node is deleted&quot;);

        if (head-&gt;next == NULL) // If there is only one node and that is deleted.
            head = 0;
        else
            prev-&gt;next = NULL;
    }
    return head;
}

NODE *delete_at_position(NODE *head) {
    NODE *cur;
    int pos, i;
    printf(&quot;Enter position:\n&quot;);
    scanf(&quot;%d&quot;, &amp;pos);
    cur = head;
    if (pos == 1) {
        head = cur-&gt;next;
    } else {
        for (i = 1; i &lt; pos - 1; i++) {
            cur = cur-&gt;next;
        }
        prev = cur;
        cur = cur-&gt;next;
        prev-&gt;next = cur-&gt;next;
    }
    cur-&gt;next = NULL;
    free(cur);
    return head;
}

// Main Function
int main() {
    int ch;
    NODE *head;
    head = NULL;

    do {
        printf(&quot;\n1.Insert Front 2.Insert Rear 3.Delete Front 4.Delete Rear 5.Display 6.Exit\n&quot;);
        printf(&quot;Enter your choice:&quot;);
        scanf(&quot;%d&quot;, &amp;ch);
        switch (ch) {
            case 1:
                head = insert_front(head);
                break;
            case 2:
                head = insert_rear(head);
                break;
            case 3:
                head = delete_front(head);
                break;
            case 4:
                head = delete_rear(head);
                break;
            case 5:
                head = delete_at_position(head);
                break;
            case 6:
                head = display(head);
                break;
            case 7:
                exit(0);
        }
    } while (ch != 6);

    return 0;
}
</code></pre><h2 id="93f61ec5-fe48-464f-a0cd-85fe541b8029" class="">Binary Tree Traversal</h2><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="6cf10063-fd2d-4a75-b10b-60ce050fbcd2" class="code"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct node {
    int data;
    struct node *left, *right;
};

struct node *create();
void inorder(struct node *ptr);
void preorder(struct node *ptr);
void postorder(struct node *ptr);

void main() {
    struct node *root;
    root = 0;
    root = create();
    printf(&quot;Inorder traversal of the tree:\n&quot;);
    inorder(root);
    printf(&quot;\nPreorder traversal of the tree:\n&quot;);
    preorder(root);
    printf(&quot;\nPostorder traversal of the tree:\n&quot;);
    postorder(root);
}

struct node *create() {
    struct node *newnode;
    int data, choice;
    printf(&quot;\nEnter your choice (0 to exit and 1 for new node):&quot;);
    scanf(&quot;%d&quot;, &amp;choice);
    if (choice == 0) {
        return 0;
    } else {
        newnode = (struct node *)malloc(sizeof(struct node));
        printf(&quot;\nEnter the data:&quot;);
        scanf(&quot;%d&quot;, &amp;newnode-&gt;data);
        printf(&quot;\nEnter the left child of %d&quot;, newnode-&gt;data);
        newnode-&gt;left = create();
        printf(&quot;\nEnter the right child of %d&quot;, newnode-&gt;data);
        newnode-&gt;right = create();
        return newnode;
    }
}

void inorder(struct node *ptr) {
    if (ptr) {
        inorder(ptr-&gt;left);
        printf(&quot;%d-&gt;&quot;, ptr-&gt;data);
        inorder(ptr-&gt;right);
    }
}

void preorder(struct node *ptr) {
    if (ptr) {
        printf(&quot;%d-&gt;&quot;, ptr-&gt;data);
        preorder(ptr-&gt;left);
        preorder(ptr-&gt;right);
    }
}

void postorder(struct node *ptr) {
    if (ptr) {
        postorder(ptr-&gt;left);
        postorder(ptr-&gt;right);
        printf(&quot;%d-&gt;&quot;, ptr-&gt;data);
    }
}</code></pre><h2 id="40fdeaff-737a-4b8b-bd97-1d12bed1344c" class="">SLL Reversal</h2><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1327be2b-c1b6-4ac4-b29f-92421def03fa" class="code"><code class="language-C">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

struct node
{
    int data;
    struct node *next; 
};
typedef struct node NODE;

// Display Function
NODE *display(NODE *head)
{
    NODE *temp;
    if(head==NULL)
    {
        printf(&quot;List is Empty\n&quot;);
        return head;
    }
    else
    {
        temp=head;
        while(temp!=NULL)
        {
            printf(&quot;\n %d \t &quot;,temp-&gt;data);
            temp=temp-&gt;next; // Go to Next Node
        }
    }
    return head;
}

// Insert Function
NODE *insert_front(NODE *head)
{
    NODE *newnode;
    newnode=(NODE *)malloc(sizeof(NODE)); 
    printf(&quot;Enter data:\n&quot;);
    scanf(&quot;%d&quot;,&amp;(newnode-&gt;data));
    newnode-&gt;next=NULL; 

    if(head==NULL)
    {   
        head=newnode;
    }
    else
    {
        newnode-&gt;next=head;
        head=newnode;
    }
    return head;
}

// Reverse the order of nodes of a singly linked list
NODE* reverseList(NODE * head)
{
    NODE *prevNode, *curNode;

    if(head != NULL)
    {
        prevNode = head;
        curNode = head-&gt;next;
        head = head-&gt;next;

        prevNode-&gt;next = NULL; // Make first node as last node

        while(head != NULL)
        {
            head = head-&gt;next;
            curNode-&gt;next = prevNode;

            prevNode = curNode;
            curNode = head;
        }

        head = prevNode; // Make last node as head

        printf(&quot;SUCCESSFULLY REVERSED LIST\n&quot;);
    }
    return head;
}

// Main Function
void main()
{
    int ch;
    NODE * head;
    head=NULL;

    do
    {
        printf(&quot;\n1.Insert Node  2.Reversing Linked List 3.Exit&quot;);
        printf(&quot;\nEnter your choice:&quot;);
        scanf(&quot;%d&quot;, &amp;ch);
        switch(ch)
        {
            case 1:
                head = insert_front(head);
                printf(&quot;Contents of List before reversing:\n&quot;);
                head = display(head);
                break;

            case 2:
                head = reverseList(head);
                printf(&quot;After reversing:\n&quot;);
                head = display(head);   
                break;

            case 3:
                exit(0);    
        }
    } while(ch != 3);
}
</code></pre><h2 id="124bed24-ae90-49cb-b722-5c41c69b5ed3" class="">Postfix</h2><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="09ec8c0a-6ccd-4136-bcf8-afb9ef01141d" class="code"><code class="language-C">#include&lt;stdio.h&gt;
#include&lt;math.h&gt;
#include&lt;string.h&gt;
#include&lt;ctype.h&gt;

double compute(char symbol, double op1, double op2) {
    switch(symbol) {
        case &#x27;+&#x27;: return op1 + op2;
        case &#x27;-&#x27;: return op1 - op2;
        case &#x27;*&#x27;: return op1 * op2;
        case &#x27;/&#x27;: return op1 / op2;
        case &#x27;$&#x27;:
        case &#x27;^&#x27;: return pow(op1, op2);
        default: return 0;
    }
}

void main() {
    double s[20], res, op1, op2;
    int top = -1, i;
    char postfix[20], symbol;
    printf(&quot;\nEnter a valid postfix expression:&quot;);
    scanf(&quot;%s&quot;, postfix);
    
    for(i = 0; i &lt; strlen(postfix); i++) {
        symbol = postfix[i];
        // Check if the symbol is a digit (number)
        if(isdigit(symbol)) {
            // If symbol is a number, push it onto the stack.
            top = top + 1;
            s[top] = symbol - &#x27;0&#x27;; // Convert char to int
        } else {
            // If symbol is an operator, then pop top two elements from the stack.
            op2 = s[top];
            top = top - 1;
            op1 = s[top];
            top = top - 1;
            res = compute(symbol, op1, op2);
            // Push the result back into the stack.
            top = top + 1;
            s[top] = res;
        }
    }
    // After computation, pop the result from the stack.
    res = s[top];
    top = top - 1;
    // Print the result.
    printf(&quot;\nThe result is: %f\n&quot;, res);
}
</code></pre><h2 id="d80a1faf-1965-40da-9516-c558f48629a5" class="">BST</h2><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="9d7e2fba-49e0-404c-b058-a4c6fcc35d27" class="code"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// Structure for a node of BST
struct Node {
    int data;
    struct Node *left;
    struct Node *right;
};

// Function to create a new node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode-&gt;data = data;
    newNode-&gt;left = NULL;
    newNode-&gt;right = NULL;
    return newNode;
}

// Function to insert a new node into BST
struct Node* insert(struct Node* root, int data) {
    if (root == NULL) {
        return createNode(data);
    }

    if (data &lt; root-&gt;data) {
        root-&gt;left = insert(root-&gt;left, data);
    } else if (data &gt; root-&gt;data) {
        root-&gt;right = insert(root-&gt;right, data);
    }

    return root;
}

// Function to display BST in inorder traversal
void displayInorder(struct Node* root) {
    if (root != NULL) {
        displayInorder(root-&gt;left);
        printf(&quot;%d &quot;, root-&gt;data);
        displayInorder(root-&gt;right);
    }
}

int main() {
    struct Node* root = NULL;

    // Inserting nodes into BST
    root = insert(root, 10);
    root = insert(root, 5);
    root = insert(root, 15);
    root = insert(root, 7);
    root = insert(root, 12);

    // Displaying BST
    printf(&quot;Inorder traversal of BST: &quot;);
    displayInorder(root);
    printf(&quot;\n&quot;);

    return 0;
}
</code></pre></div></article><span class="sans" style="font-size:14px;padding-top:2em"></span></body></html>